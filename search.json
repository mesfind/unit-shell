[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Unix Shell",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Unix Shell",
    "section": "",
    "text": "The final one can be done in a variety of ways, such as with a keyboard and mouse, touch screen interfaces, or speech recognition software. Although touch and speech interfaces are increasingly prevalent, traditional screens, mouse, touchpads, and keyboards are still used for the majority of interactions.\nGraphical user interfaces (GUI) are composed of windows, icons, and pointers, which are all familiar to us. They are simple to use and great for simple jobs because their vocabulary only contains the word “click,” which is simply translated into “do what I want.” However, for this magic to work, you must have applications that can perform a small number of simple tasks.\n\n\nA typical shell window looks something like:\nThe shell will produce an error message similar to this one if it cannot locate a program whose name matches the command you typed:\n\n\n\n\n\n\nPay Attention\n\n\n\nCommand not found\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nA shell is a program whose primary purpose is to read commands and run other programs.\nThe shell’s main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and its capacity to access networked machines.\nThe shell’s main disadvantages are its primarily textual nature and how cryptic its commands and operation can be.\n\n\n\n\n\n\nThe file system is the area of the operating system that controls files and directories. Our data is organized into files—which contain information—and directories—also known as “folders,” which house either other files or other directories.\nTo create, examine, rename, and delete files and directories, a number of commands are routinely used. We’ll proceed to our shell window that is open to begin studying them.\nFirst, let’s use the pwd command (which stands for “print working directory”) to determine our location. Directories are like places; whenever we use the shell, we are always in the same location, which is the current working directory.\n\npwd\n\n'/Users/admin/Rproject/HPC'\n\n\nHere, the computer’s response is /Users/admin/Rproject/HPC, which is admin’s home directory:\n\n\nThe home directory path will look different on different operating systems. On Linux it may look like /home/admin, and on Windows it will be similar to C:and Settingsor C:. (Note that it may look slightly different for different versions of Windows.) In future examples, we’ve used Mac output as the default - Linux and Windows output may differ slightly, but should be generally similar. To understand what a “home directory” is, let’s have a look at how the file system as a whole is organized. For the sake of this example, we’ll be illustrating the filesystem on our scientist Nelle’s computer. After this illustration, you’ll be learning commands to explore your own filesystem, which will be constructed in a similar way, but not be exactly identical.\nOn Admin’s computer, the filesystem looks like this:\n\nThe root directory, which contains everything else, is located at the top. We refer to it by using the single slash (/), which is the first slash in the path /Users/admin.\nSeveral more folders can be found inside that one, including tmp (for temporary files that don’t need to be kept for a long time), Users (where users’ personal directories are put), and bin (where some built-in programs are stored).\nSince /Users is the initial letter of its name, we know that our current working directory, /Users/admin, is located inside of /Users. Similarly, since its name starts with /, we know that /Users is located inside the root directory.\n\n\n\nNow let’s learn the command that will let us see the contents of our own filesystem. We can see what’s in our home directory by running ls, which stands for “listing”:\n\nls \n\nHPC.Rproj              _site/                 intro.ipynb\nHPC.qmd                cover.png              intro.qmd\nQE/                    docs/                  references.bib\n_book/                 files_directories.qmd  references.qmd\n_freeze/               img/\n_quarto.yml            index.qmd\n\n\nls prints the names of the files and directories in the current directory. We can make its output more comprehensible by using the flag -F (also known as a switch or an option) , which tells ls to add a marker to file and directory names to indicate what they are. A trailing / indicates that this is a directory. Depending on your settings, it might also use colors to indicate whether each entry is a file or directory. You might recall that we used ls -F in an earlier example.\n\nls -F\n\nHPC.Rproj              _site/                 intro.ipynb\nHPC.qmd                cover.png              intro.qmd\nQE/                    docs/                  references.bib\n_book/                 files_directories.qmd  references.qmd\n_freeze/               img/\n_quarto.yml            index.qmd\n\n\n\n\n\nls has lots of other flags. There are two common ways to find out how to use a command and what flags it accepts:\n\nWe can pass --help flag to the command such as:\n\n\nls --help\n\n\n\n\n\n\nUnsupported commnad-line options\n\n\n\n\n\n\nIf you try to use an option (flag) that is not supported, ls and other programs will usually print an error message similar to:\nls -j\nls: invalid option -- j\n\n\n\nThe other way to learn about ls is to type\n\nman ls\n\nThis will turn your terminal into a page with a description of the ls command and its options and, if you’re lucky, some examples of how to use it.\nTo navigate through the man pages, you may use ↑ and ↓ to move line-by-line, or try B and Spacebar to skip up and down by a full page. To search for a character or word in the man pages, use / followed by the character or word you are searching for.\nTo quit the man pages, press Q.\n\n\n\nOf course there is a third way to access help for commands: searching the internet via your web browser. When using internet search, including the phrase unix man page in your search query will help to find relevant results.\nGNU provides links to its manuals including the core GNU utilities, which covers many commands introduced within this lesson.\n\n\n\nWhat does the command ls do when used with the -l and -h flags?\nSome of its output is about properties that we do not cover in this lesson (such as file permissions and ownership), but the rest should be useful nevertheless.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe -l flag makes ls use a long listing format, showing not only the file/directory names but also additional information such as the file size and the time of its last modification. The -h flag makes the file size “human readable”, i.e. display something like 5.3K instead of 5369.\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe command ls -R lists the contents of directories recursively, i.e., lists their sub-directories, sub-sub-directories, and so on at each level. The command ls -t lists things by time of last change, with most recently changed files or directories first. In what order does ls -R -t display things? Hint: ls -l uses a long listing format to view timestamps\n\n\n\nHere, we can see that our home directory contains mostly sub-directories. Any names in your output that don’t have trailing slashes, are plain old files. And note that there is a space between ls and -F: without it, the shell thinks we’re trying to run a command called ls-F, which doesn’t exist.\nWe can also use ls to see the contents of a different directory. Let’s take a look at our Desktop directory by running ls -F Desktop, i.e., the command ls with the -F flag and the argument Desktop. The argument Desktop tells ls that we want a listing of something other than our current working directory:\n\nls -F Desktop\n\nls: Desktop: No such file or directory\n\n\nYour output should be a list of all the files and sub-directories on your Desktop, including the data-shell directory you downloaded at the setup for this lesson. Take a look at your Desktop to confirm that your output is accurate.\nAs you may now see, using a bash shell is strongly dependent on the idea that your files are organized in a hierarchical file system. Organizing things hierarchically in this way helps us keep track of our work: it’s possible to put hundreds of files in our home directory, just as it’s possible to pile hundreds of printed papers on our desk, but it’s a self-defeating strategy.\nNow that we know the data-shell directory is located on our Desktop, we can do two things.\nFirst, we can look at its contents, using the same strategy as before, passing a directory name to ls:\n\nls -F Desktop/data-shell\n\nls: Desktop/data-shell: No such file or directory\n\n\nSecond, we can actually change our location to a different directory, so we are no longer located in our home directory.\nThe command to change locations is cd followed by a directory name to change our working directory. cd stands for “change directory”, which is a bit misleading: the command doesn’t change the directory, it changes the shell’s idea of what directory we are in.\nLet’s say we want to move to the data directory we saw above. We can use the following series of commands to get there:\n\n$ cd Desktop\n$ cd data-shell\n$ cd data\n\nThese commands will move us from our home directory onto our Desktop, then into the data-shell directory, then into the data directory. cd doesn’t print anything, but if we run pwd after it, we can see that we are now in /Users/admin/Desktop/data-shell/data. If we run ls without arguments now, it lists the contents of /Users/admin/Desktop/data-shell/data, because that’s where we now are:\n\npwd\n\n'/Users/admin/Rproject/HPC'\n\n\nBut we get an error! Why is this?\nWith our methods so far, cd can only see sub-directories inside your current directory. There are different ways to see directories above your current location; we’ll start with the simplest.\nThere is a shortcut in the shell to move up one directory level that looks like this:\n\ncd ..\n\n/Users/admin/Rproject\n\n\n.. is a special directory name meaning “the directory containing this one”, or more succinctly, the parent of the current directory. Sure enough, if we run pwd after running cd .., we’re back in /Users/admin/Desktop/data-shell:\n\npwd\n\n'/Users/admin/Rproject'\n\n\nThe special directory .. doesn’t usually show up when we run ls. If we want to display it, we can give ls the -a flag:\n\nls -F -a\n\n./              .DS_Store       .Rhistory       Afrasa/         Rproject.Rproj\n../             .RData          .Rproj.user/    HPC/\n\n\n-a stands for “show all”; it forces ls to show us file and directory names that begin with ., such as .. (which, if we’re in /Users/admin, refers to the /Users directory) As you can see, it also displays another special directory that’s just called ., which means “the current working directory”. It may seem redundant to have a name for it, but we’ll see some uses for it soon.\nNote that in most command line tools, multiple flags can be combined with a single - and no spaces between the flags: ls -F -a is equivalent to ls -Fa.\n\n\n\nIn addition to the hidden directories .. and ., you may also see a file called .bash_profile. This file usually contains shell configuration settings. You may also see other files and directories beginning with .. These are usually files and directories that are used to configure different programs on your computer. The prefix . is used to prevent these configuration files from cluttering the terminal when a standard ls command is used.\n\n\n\n\nAbsolute Path\n\nAn absolute path is defined as specifying the location of a file or directory from the root directory(/). In other words,we can say that an absolute path is a complete path from start of actual file system from / directory.\n\nRelative Path\n\nRelative path is defined as the path related to the present working directly(pwd). It starts at your current directory and never starts with a /\n\n\nUNIX offers a shortcut in the relative pathname– that uses either the current or parent directory as reference and specifies the path relative to it. A relative path-name uses one of these cryptic symbols:\n\n\n\n\n\n\nrelative pathname\n\n\n\n.(a single dot) - this represents the current directory.\n..(two dots) - this represents the parent directory.\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\nThe file system is responsible for managing information on the disk.\nInformation is stored in files, which are stored in directories (folders).\nDirectories can also store other directories, which forms a directory tree.\ncd path changes the current working directory.\nls path prints a listing of a specific file or directory; ls on its own lists the current working directory.\npwd prints the user’s current working directory.\n/ on its own is the root directory of the whole file system.\nA relative path specifies a location starting from the current location.\nAn absolute path specifies a location from the root of the file system.\nDirectory names in a path are separated with / on Unix, but \\ on Windows.\n.. means ‘the directory above the current one’; . on its own means ‘the current directory’.\nMost files’ names are something.extension. The extension isn’t required, and doesn’t guarantee anything, but is normally used to indicate the type of data in the file"
  },
  {
    "objectID": "HPC.html",
    "href": "HPC.html",
    "title": "Unix Shell",
    "section": "",
    "text": "The benefits of using HPC systems for research often far outweigh the cost of learning to use a Shell and include:\n\nSpeed. With many more CPU cores, often with higher performance specs, than the computers most people have access to HPC systems can offer significant speed up.\nVolume. Many HPC systems have both the processing memory (RAM) and disk storage to handle very large amounts of data.\nEfficiency. Many HPC systems operate a pool of resources that are drawn on by a many users.\nCost. Bulk purchasing and government funding mean that the cost to the research community for using these systems in significantly less that it would be otherwise.\nKeep personal resources free. By using an HPC system when required your own personal computer can be used for other things to which it is better suited, like email and spreadsheets.\n\n\n\n\nHigh Performance Computing (HPC) typically involves connecting to very large computing systems elsewhere in the world.\nThese other systems can be used to do work that would either be impossible or much slower on smaller systems.\nHPC resources are shared by multiple users.\nThe standard method of interacting with such systems is via a command line interface.\n\n\n\n\nMaking a link from our laptop to the cluster is the first step in using a cluster. We have grown accustomed to expecting a visual display with icons, widgets, and possibly some windows or apps when using a computer while seated (or standing, holding it in our hands, or wearing it on our wrists). This visual display is known as a graphical user interface, or GUI. It is more practical to use a command-line interface, or CLI, to convey commands as plain-text because computer clusters are remote resources that we connect to across sluggish or intermittent interfaces (WiFi and VPNs especially). A command’s output is also shown as plain text if it returns any. The instructions we execute today won’t launch a window to display graphic outcomes.\nA CLI can be observed if you’ve ever launched the Windows Command Prompt or the macOS Terminal. You have used the CLI extensively on your local machine if you have previously attended The Carpentries’ courses on the UNIX Shell or Version Control. The sole necessary step in this case is to launch a CLI on a distant machine while taking security precautions to prevent other network users from seeing (or altering) the commands you’re executing or the output the remote machine returns. You can send and receive text and data without worrying about prying eyes by opening an encrypted network connection between two machines using the Secure SHell protocol (also known as SSH).\n\nSSH clients are often command-line programs where the only argument needed is the address of the remote machine. You must also enter your username if it is different from your local login on the distant system. You should set these arguments before selecting “connect” if your SSH client includes a graphical user interface, such PuTTY or MobaXterm. In the terminal, type something like ssh userName@hostname, where “@” separates the user’s ID from the hostname of the remote system. This argument works just like an email address.\nA username, password, or pattern must typically be entered when logging into a laptop, tablet, or other personal device to prevent unwanted access. Since logging your keystrokes needs a malicious exploit or physical access in certain circumstances, the risk of someone else intercepting your password is negligible. Anyone on the network is able to log in, or attempt to log in, to systems like gra-login1 that operate an SSH server. Your password is frequently the weakest link in the security chain because usernames are frequently made public or are simple to guess. As a result, a lot of clusters disallow password-based login and demand that you create and configure a public-private key pair with a strong password.\n\n\n\n\nHPC systems often provide a lot of different software packages\nHPC provides ways of selecting and configuring them to get the environment you need.\nIt has multiple versions of commonly used software packages installed called Environmental Modules\n\n\n\n\n\nHigh Performance Computing is not the same as cloud computing.\nHPC targets extremely large sets of data and crunching the information in parallel while sharing the data between compute nodes\nIn HPC one application can be run across a variable number of nodes. We call this vertical scalability.\nCloud computing on the other hand targets “embarrassingly parallel problems” (EPP) with little or no effort is required to separate the problem into a number of parallel tasks.\nIn a cloud several applications (or, copies of the same application) run on several nodes. We call this horizontal scalability.\nHPC systems are generally constructed:\n\nfrom many individual computers\nsimilar in capability to many personal computers\nconnected together by some type of network\n\nHPC systems often include several different types of nodes:\n\nMaster(or front-end or login) nodes\nCompute nodes\n\n\n\n\n\n\n\nHPC cluster Schematic\n\n\n\n\n\n\n\nEach node on an HPC system is essentially an individual computer\n\n\n\n\n\nHPC Nodes Schematic\n\n\n\n\n\n\n\n\nTo manage the sharing of the compute nodes among all of the jobs, HPC systems use a batch system(scheduler).\nThe batch system usually has commands for:\n\nsubmitting jobs\ninquiring about their status\nand modifying them\n\na typical HPC workflow could look something like this:\n\nTransfer input datasets to the HPC system (via the master nodes)\nCreate a job submission script to perform your computation (on Master nodes)\nSubmit your job submission script to the scheduler (on Master nodes)\nScheduler runs your computation (on the compute nodes)\nAnalyse results from your computation (on the login or compute nodes)\n\n\n\n\n\n\nHPC systems often involves very large files, and/or many of them.\nHPC systems have specialized file systems that are designed to meet different needs.\nmost HPC systems often have several different file systems available\n\n\n\n\n\n\nThe workflow for using HPC typically consists of the following steps:\n\nLogin to HPC login/head node.\nOrganize workspace.\nTransfer data and files.\nInstall/run software on HPC.\nTest your job interactively on a compute node.\nSubmit your job to the batch processor, to run it remotely on a compute node.\nMonitor your job and check your results when it has completed.\n\n\n\n\n\n\n\n\nConnecting to an HPC system is most often done through a tool known as “SSH” (Secure SHell)\nTo begin using an HPC system we need to begin by opening a terminal.\nSSH allows us to connect to Linux computers remotely, and use them as if they were our own.\nLet’s attempt to connect to the HPC system now:\n\n\n      ssh yourUsername@hpc.ethernet.edu.et\n\n\n\n\n\n\n\n\nNow we can log into the Ethernet HPC system we will look at the nodes.\nThere are at least two types of node on the system: login nodes and compute nodes.\nWe can use the lscpu command to print information on the processors on the login nodes to the terminal:\n\n\n   [remote]$ lscpu\n\n\nus the total amount of memory available so we use the head -1 command:\n\n\n      [remote]$ head -1 /proc/meminfo\n      \n\n\nThe qsub command is used to submit a job to the scheduler.\n\n\n\n\n\n\nMultiple versions of software are available on HPC systems\nThe three biggest factors to have multiple versions of software are :\n\nsoftware incompatibilities;\nversioning;\ndependencies.\n\nEnvironment modules are the solution to these problems.\nA module is a self-contained description of a software package\nThere are a number of different environment module implementations commonly used on HPC systems: the two most common are TCL modules(Tmod) and Lmod.\nOne major difference between the two tools is that Lmod is written in Lua and not TCL.\nLmod: An Environment Module System based on Lua, Reads TCL Modules, Supports a Software Hierarchy\nLmod has to translate TCL into Lua\n\n\n\n\n\nYou can use the module list command to see which modules you currently have loaded in your environment.\nIf you have no modules loaded, you will see a message telling you so\n\n\n[remote]$ module list\n\n\n    No Modulefiles Currently Loaded.\n\n\nTo see available modules, use module avail\n\n\n[remote]$ module avail\n\n\nTo load a software module, use module load. Hence We can load the openmpi-x86_64 command with module load:\n\n\n[remote]$ module load openmpi-x86_64\n[remote]$ which openmpi-x86_64\n\n\n\n\n\n\n\nthe easiest tool to download files from the internet is wget.\nThe syntax is relatively straightforward:\n\n\n   [remote]$ wget https://mesfind.github.io/hpc/files/cfd.tar.gz\n\n\n\n\n\nTo copy a single file to or from the remote system, we can use scp.\n\n\n[local]$ scp local-file.txt yourUsername@remote.computer.address:\n\n\nTo transfer to another computer:\n\n\n[local]$ scp file.txt yourUsername@remote.computer.address: path\n\n\n\n\n\nsftp is an interactive way of downloading and uploading files.\nLet’s connect to a remote system using sftp\n\n\n  [local]$ sftp yourUsername@ethernet.edu.et\n  \n\n\n\n\n\nWe can see which commands are available with ? or help:\n\n\n    sftp> ?\n\n\nsftp> help\n\n\n\n\n\nTo show our remote working directory:\n\n\n   sftp> pwd\n\n\nTo show our local working directory, we add an l in front of the command:\n\n\n    sftp> lpwd\n\n\n\n\n\nListing files and directories in local as well as remote system.\n\n\n   sftp> ls\n\n\n\nListing files and directories in local as well on local system.\n\n\n\n    sftp> lls\n\n\n\n\n\nwe can put single or multiple files in remote system.\nTo upload a file, we type put some-file.txt\n\n\n    sftp> put input.dat\n\n\n\n\n\n    sftp> mput *.c\n\n\n\n\n\nTo download a file we type get some-file.txt:\n\n\n    sftp> get input.dat\n\n\n\n\n\nGet multiple files on a local system\n\n\n    sftp> mget input.dat\n\n\n\n\n\nSwitching from one directory to another directory in local and remote locations.\non a remote system\n\n\n    sftp> cd test\n\n\non a local system\n\n\n    sftp> lcd Desktop\n\n\n\n\n\nCreating new directories on local and remote locations.\n\n\n    sftp> mkdir test\n\n\n    sftp> lmkdir openmpi\n\n\nThe most basic use of the scheduler is to run a command non-interactively.\nThis is also referred to as batch job submission. I\nIn this case, a job is just a shell script. Let’s create a demo shell script to run as a test.\n\n\n#!/bin/bash\n# Save with example_job.sh\necho 'This script is running on:'\nhostname\nsleep 120\n\n\nTo submit this job to the scheduler, we use the sbatch command.\n\n\nsbatch example_job.sh\n\n\nTo check on our job’s status, we check the queue using the command\n\n\nsbatch example_job.sh"
  },
  {
    "objectID": "files_directories.html",
    "href": "files_directories.html",
    "title": "Unix Shell",
    "section": "",
    "text": "Let’s create a new directory called thesis using the command mkdir QE (which has no output):\n\nmkdir qe\n\nAs you might guess from its name, mkdir means “make directory”. Since qe is a relative path (i.e., doesn’t have a leading slash), the new directory is created in the current working directory:\nSince we’ve just created the qe directory, there’s nothing in it yet:\n\nls -F qe\n\nls: qe: No such file or directory\n\n\n\n\nWe can move our new file into the new directory with the move command, mv. The syntax of mv is $ mv file_being_moved location_moving_to. Moving our new file “QE” to our new directory “qe” can be done as follows:\n\nmv qe QE\n\nmv: rename qe to QE: No such file or directory\n\n\n\n$ cd QE\n\nLet’s change our working directory to QE using cd, then run a text editor called vi to create a file called si.in :\n\n$ vi si.in\n\n\n\nText editors can be used for writing code, editing text files such as configuration files, creating user instruction files, and many more. In Linux, text editors are of two kinds that is the graphical user interface (GUI) and command-line text editors (console or terminal).\n\n\n\nVim is a powerful command-line based text editor that has enhanced the functionalities of the old Unix Vi text editor. It is one the most popular and widely used text editors among System Administrators and programmers that is why many users often refer to it as a programmer’s editor.\n\n\n\n\n\n\nVi/Vim Save and Quit command\n\n\n\nThe procedure to save a file in vi/vim and quit the editor is as follows:\n\nopen the file with vi filename( e.g vi si.in)\nto save a file and quit press Esc key , type :wq ( or `:x`)\nhit Enter key\n\n\n\n\n\n\nWe have seen how to create text files using the vi/vim editor. Now, try the following command in your home directory:\n\ntouch QE/si.out\n\n\n\n\n\nWe can also copy files, leaving the original file while a second version is created either elsewhere or in the same location. The copy command is cp and its syntax is the same as for mv: $ cp file_being_copied location_copying_to. We can create a copy of “QE” into “qe” directory as follows:\n\ncp QE qe \n\ncp: QE: No such file or directory\n\n\n\n\n\nIf we try to remove the entire thesis directory using rm QE, we get an error message:\n\nrm QE\n\n\n\n\n\n\n\nUsing rm Safely\n\n\n\nWhat happens when we execute rm -i QE/si.out? Why would we want this protection when using rm?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nrm: remove regular file 'QE/si.out'?\nThe -i flag will prompt before every removal. The Unix shell doesn’t have a trash bin, so all the files removed will disappear forever. By using the -i flag, we have the chance to check that we are deleting only the files that we want to remove.\n\n\n\n\n\n\n\n\n\nWith Great Power Comes Great Responsibility\n\n\n\nRemoving the files in a directory recursively can be a very dangerous operation. If we’re concerned about what we might be deleting we can add the “interactive” flag -i to rm which will ask us for confirmation before each step\n\n$ rm -r -i QE\n  rm: descend into directory ‘QE’? y\n  rm: remove regular file ‘QE/si.in’? y\n  rm: remove regular file ‘QE/si.out’? y\n  rm: remove directory ‘QE’? y\n\n\n\n\n\n\n\n\n\nKey Points\n\n\n\n\ncp old new copies a file.\nmkdir path creates a new directory.\nmv old new moves (renames) a file or directory.\nrm path removes (deletes) a file.\n* matches zero or more characters in a filename, so *.txt matches all files ending in .txt.\n? matches any single character in a filename, so ?.txt matches a.txt but not any.txt.\nUse of the Control key may be described in many ways, including Ctrl-X, Control-X, and ^X.\nThe shell does not have a trash bin: once something is deleted, it's really gone.\nDepending on the type of work you do, you may need a more powerful text editor than vi."
  },
  {
    "objectID": "pipes_filters.html",
    "href": "pipes_filters.html",
    "title": "Unix Shell",
    "section": "",
    "text": "Pipes and Filters\nNow that we know a few basic commands, we can finally look at the shell’s most powerful feature: the ease with which it lets us combine existing programs in new ways. We’ll start with a directory called molecules that contains six files describing some simple organic molecules.\n\n$ ls mini_workshop/Si\n\nLet’s go into that directory with cd and run the command wc *.in. wc is the “word count” command: it counts the number of lines, words, and characters in files (from left to right, in that order).\n\ncd mini_workshop/Si\n$ wc *.in"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Unix Shell",
    "section": "",
    "text": "Unix Shell\nThe Unix shell has existed for longer than the majority of its users have. It has endured for so long because it is a powerful tool that enables users to complete complicated tasks with a minimal number of keystrokes. More importantly, it makes it possible for users to integrate already-existing programs in novel ways and automate monotonous chores so they won’t have to repeatedly type the same things. The shell must be used in order to utilize many other potent tools and computational resources, such as supercomputers used for “high-performance computing.” These classes will put you on the right path to efficiently utilising these resources.\nYou will learn the fundamentals of file systems and the shell in this session. You are prepared for this course if you have ever stored files on a computer and are familiar with the terms “file,” “directory,” or “folder” (two common names for the same thing).\nA shell is just another type of program. It is unique in that its function is to execute other programs rather than carry out calculations on its own. The Bourne Again SHell, or Bash (so named because it was evolved from a shell created by Stephen Bourne), is the most widely used Unix shell. The default shell on the majority of contemporary Unix systems and in the majority of Windows packages that offer Unix-like features uses the name Bash.\nThe Unix shell has existed for longer than the majority of its users have. It has endured for so long because it is a powerful tool that enables users to complete complicated tasks with a minimal number of keystrokes. More importantly, it makes it possible for users to integrate already-existing programs in novel ways and automate monotonous chores so they won’t have to repeatedly type the same things. The shell must be used in order to utilize many other potent tools and computational resources, such as supercomputers used for “high-performance computing.” These classes will put you on the right path to efficiently utilising these resources."
  }
]